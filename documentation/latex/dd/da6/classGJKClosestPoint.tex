\doxysection{GJKClosest\+Point Class Reference}
\hypertarget{classGJKClosestPoint}{}\label{classGJKClosestPoint}\index{GJKClosestPoint@{GJKClosestPoint}}


{\ttfamily \#include $<$GJKClosest\+Point.\+h$>$}



Inheritance diagram for GJKClosest\+Point\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=230pt]{d9/d66/classGJKClosestPoint__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for GJKClosest\+Point\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=230pt]{db/d6a/classGJKClosestPoint__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename A , typename B $>$ }\\bool \mbox{\hyperlink{classGJKClosestPoint_a20ab4d36efcf62ceae244ec75eb4bc23}{Intersects}} (const A \&inA, const B \&inB, float in\+Tolerance, \mbox{\hyperlink{classVec3}{Vec3}} \&ioV)
\item 
{\footnotesize template$<$typename A , typename B $>$ }\\float \mbox{\hyperlink{classGJKClosestPoint_abb7cfdd49d708007d75b4c2e9b90ebb9}{Get\+Closest\+Points}} (const A \&inA, const B \&inB, float in\+Tolerance, float in\+Max\+Dist\+Sq, \mbox{\hyperlink{classVec3}{Vec3}} \&ioV, \mbox{\hyperlink{classVec3}{Vec3}} \&out\+PointA, \mbox{\hyperlink{classVec3}{Vec3}} \&out\+PointB)
\item 
void \mbox{\hyperlink{classGJKClosestPoint_a73d6f276fb275026a0126ca7361fb2bf}{Get\+Closest\+Points\+Simplex}} (\mbox{\hyperlink{classVec3}{Vec3}} \texorpdfstring{$\ast$}{*}outY, \mbox{\hyperlink{classVec3}{Vec3}} \texorpdfstring{$\ast$}{*}outP, \mbox{\hyperlink{classVec3}{Vec3}} \texorpdfstring{$\ast$}{*}outQ, uint \&out\+Num\+Points) const
\item 
{\footnotesize template$<$typename A $>$ }\\bool \mbox{\hyperlink{classGJKClosestPoint_ade3cde48252b6f77f749f9ac29685ec7}{Cast\+Ray}} (\mbox{\hyperlink{classVec3}{Vec3\+Arg}} in\+Ray\+Origin, \mbox{\hyperlink{classVec3}{Vec3\+Arg}} in\+Ray\+Direction, float in\+Tolerance, const A \&inA, float \&io\+Lambda)
\item 
{\footnotesize template$<$typename A , typename B $>$ }\\bool \mbox{\hyperlink{classGJKClosestPoint_a66d20557ad6d34a1c1f29b6df058b523}{Cast\+Shape}} (\mbox{\hyperlink{classMat44}{Mat44\+Arg}} in\+Start, \mbox{\hyperlink{classVec3}{Vec3\+Arg}} in\+Direction, float in\+Tolerance, const A \&inA, const B \&inB, float \&io\+Lambda)
\item 
{\footnotesize template$<$typename A , typename B $>$ }\\bool \mbox{\hyperlink{classGJKClosestPoint_aa5b19da7e23744cb5c1af8fe2fee2940}{Cast\+Shape}} (\mbox{\hyperlink{classMat44}{Mat44\+Arg}} in\+Start, \mbox{\hyperlink{classVec3}{Vec3\+Arg}} in\+Direction, float in\+Tolerance, const A \&inA, const B \&inB, float in\+Convex\+RadiusA, float in\+Convex\+RadiusB, float \&io\+Lambda, \mbox{\hyperlink{classVec3}{Vec3}} \&out\+PointA, \mbox{\hyperlink{classVec3}{Vec3}} \&out\+PointB, \mbox{\hyperlink{classVec3}{Vec3}} \&out\+Separating\+Axis)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classNonCopyable}{Non\+Copyable}}}
\begin{DoxyCompactItemize}
\item 
{\bfseries Non\+Copyable} (const \mbox{\hyperlink{classNonCopyable}{Non\+Copyable}} \&)=delete
\item 
void {\bfseries operator=} (const \mbox{\hyperlink{classNonCopyable}{Non\+Copyable}} \&)=delete
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Convex vs convex collision detection Based on\+: A Fast and Robust GJK Implementation for Collision Detection of Convex Objects -\/ Gino van den Bergen 

\doxysubsection{Member Function Documentation}
\Hypertarget{classGJKClosestPoint_ade3cde48252b6f77f749f9ac29685ec7}\label{classGJKClosestPoint_ade3cde48252b6f77f749f9ac29685ec7} 
\index{GJKClosestPoint@{GJKClosestPoint}!CastRay@{CastRay}}
\index{CastRay@{CastRay}!GJKClosestPoint@{GJKClosestPoint}}
\doxysubsubsection{\texorpdfstring{CastRay()}{CastRay()}}
{\footnotesize\ttfamily template$<$typename A $>$ \\
bool GJKClosest\+Point\+::\+Cast\+Ray (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVec3}{Vec3\+Arg}}}]{in\+Ray\+Origin,  }\item[{\mbox{\hyperlink{classVec3}{Vec3\+Arg}}}]{in\+Ray\+Direction,  }\item[{float}]{in\+Tolerance,  }\item[{const A \&}]{inA,  }\item[{float \&}]{io\+Lambda }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Test if a ray in\+Ray\+Origin + lambda \texorpdfstring{$\ast$}{*} in\+Ray\+Direction for lambda e \mbox{[}0, io\+Lambda\texorpdfstring{$>$}{>} instersects inA

Code based upon\+: \doxylink{structRay}{Ray} Casting against General Convex Objects with Application to Continuous Collision Detection -\/ Gino van den Bergen


\begin{DoxyParams}{Parameters}
{\em in\+Ray\+Origin} & Origin of the ray \\
\hline
{\em in\+Ray\+Direction} & Direction of the ray (io\+Lambda \texorpdfstring{$\ast$}{*} in\+Direction determines length) \\
\hline
{\em in\+Tolerance} & The minimal distance between the ray and A before it is considered colliding \\
\hline
{\em inA} & A convex object that has the Get\+Support(\+Vec3) function \\
\hline
{\em io\+Lambda} & The max fraction along the ray, on output updated with the actual collision fraction.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a hit was found, io\+Lambda is the solution for lambda. 
\end{DoxyReturn}
\Hypertarget{classGJKClosestPoint_a66d20557ad6d34a1c1f29b6df058b523}\label{classGJKClosestPoint_a66d20557ad6d34a1c1f29b6df058b523} 
\index{GJKClosestPoint@{GJKClosestPoint}!CastShape@{CastShape}}
\index{CastShape@{CastShape}!GJKClosestPoint@{GJKClosestPoint}}
\doxysubsubsection{\texorpdfstring{CastShape()}{CastShape()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename A , typename B $>$ \\
bool GJKClosest\+Point\+::\+Cast\+Shape (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMat44}{Mat44\+Arg}}}]{in\+Start,  }\item[{\mbox{\hyperlink{classVec3}{Vec3\+Arg}}}]{in\+Direction,  }\item[{float}]{in\+Tolerance,  }\item[{const A \&}]{inA,  }\item[{const B \&}]{inB,  }\item[{float \&}]{io\+Lambda }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Test if a cast shape inA moving from in\+Start to lambda \texorpdfstring{$\ast$}{*} in\+Start.\+Get\+Translation() + in\+Direction where lambda e \mbox{[}0, io\+Lambda\texorpdfstring{$>$}{>} instersects inB


\begin{DoxyParams}{Parameters}
{\em in\+Start} & Start position and orientation of the convex object \\
\hline
{\em in\+Direction} & Direction of the sweep (io\+Lambda \texorpdfstring{$\ast$}{*} in\+Direction determines length) \\
\hline
{\em in\+Tolerance} & The minimal distance between A and B before they are considered colliding \\
\hline
{\em inA} & The convex object A, must support the Get\+Support(\+Vec3) function. \\
\hline
{\em inB} & The convex object B, must support the Get\+Support(\+Vec3) function. \\
\hline
{\em io\+Lambda} & The max fraction along the sweep, on output updated with the actual collision fraction.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a hit was found, io\+Lambda is the solution for lambda. 
\end{DoxyReturn}
\Hypertarget{classGJKClosestPoint_aa5b19da7e23744cb5c1af8fe2fee2940}\label{classGJKClosestPoint_aa5b19da7e23744cb5c1af8fe2fee2940} 
\index{GJKClosestPoint@{GJKClosestPoint}!CastShape@{CastShape}}
\index{CastShape@{CastShape}!GJKClosestPoint@{GJKClosestPoint}}
\doxysubsubsection{\texorpdfstring{CastShape()}{CastShape()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename A , typename B $>$ \\
bool GJKClosest\+Point\+::\+Cast\+Shape (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMat44}{Mat44\+Arg}}}]{in\+Start,  }\item[{\mbox{\hyperlink{classVec3}{Vec3\+Arg}}}]{in\+Direction,  }\item[{float}]{in\+Tolerance,  }\item[{const A \&}]{inA,  }\item[{const B \&}]{inB,  }\item[{float}]{in\+Convex\+RadiusA,  }\item[{float}]{in\+Convex\+RadiusB,  }\item[{float \&}]{io\+Lambda,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \&}]{out\+PointA,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \&}]{out\+PointB,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \&}]{out\+Separating\+Axis }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Test if a cast shape inA moving from in\+Start to lambda \texorpdfstring{$\ast$}{*} in\+Start.\+Get\+Translation() + in\+Direction where lambda e \mbox{[}0, io\+Lambda\texorpdfstring{$>$}{>} instersects inB


\begin{DoxyParams}{Parameters}
{\em in\+Start} & Start position and orientation of the convex object \\
\hline
{\em in\+Direction} & Direction of the sweep (io\+Lambda \texorpdfstring{$\ast$}{*} in\+Direction determines length) \\
\hline
{\em in\+Tolerance} & The minimal distance between A and B before they are considered colliding \\
\hline
{\em inA} & The convex object A, must support the Get\+Support(\+Vec3) function. \\
\hline
{\em inB} & The convex object B, must support the Get\+Support(\+Vec3) function. \\
\hline
{\em in\+Convex\+RadiusA} & The convex radius of A, this will be added on all sides to pad A. \\
\hline
{\em in\+Convex\+RadiusB} & The convex radius of B, this will be added on all sides to pad B. \\
\hline
{\em io\+Lambda} & The max fraction along the sweep, on output updated with the actual collision fraction. \\
\hline
{\em out\+PointA} & is the contact point on A (if out\+Separating\+Axis is near zero, this may not be not the deepest point) \\
\hline
{\em out\+PointB} & is the contact point on B (if out\+Separating\+Axis is near zero, this may not be not the deepest point) \\
\hline
{\em out\+Separating\+Axis} & On return this will contain a vector that points from A to B along the smallest distance of separation. The length of this vector indicates the separation of A and B without their convex radius. If it is near zero, the direction may not be accurate as the bodies may overlap when lambda = 0.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a hit was found, io\+Lambda is the solution for lambda and out\+Point and out\+Separating\+Axis are valid. 
\end{DoxyReturn}
\Hypertarget{classGJKClosestPoint_abb7cfdd49d708007d75b4c2e9b90ebb9}\label{classGJKClosestPoint_abb7cfdd49d708007d75b4c2e9b90ebb9} 
\index{GJKClosestPoint@{GJKClosestPoint}!GetClosestPoints@{GetClosestPoints}}
\index{GetClosestPoints@{GetClosestPoints}!GJKClosestPoint@{GJKClosestPoint}}
\doxysubsubsection{\texorpdfstring{GetClosestPoints()}{GetClosestPoints()}}
{\footnotesize\ttfamily template$<$typename A , typename B $>$ \\
float GJKClosest\+Point\+::\+Get\+Closest\+Points (\begin{DoxyParamCaption}\item[{const A \&}]{inA,  }\item[{const B \&}]{inB,  }\item[{float}]{in\+Tolerance,  }\item[{float}]{in\+Max\+Dist\+Sq,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \&}]{ioV,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \&}]{out\+PointA,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \&}]{out\+PointB }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get closest points between inA and inB


\begin{DoxyParams}{Parameters}
{\em inA} & The convex object A, must support the Get\+Support(\+Vec3) function. \\
\hline
{\em inB} & The convex object B, must support the Get\+Support(\+Vec3) function. \\
\hline
{\em in\+Tolerance} & The minimal distance between A and B before the objects are considered colliding and processing is terminated. \\
\hline
{\em in\+Max\+Dist\+Sq} & The maximum squared distance between A and B before the objects are considered infinitely far away and processing is terminated. \\
\hline
{\em ioV} & Initial guess for the separating axis. Start with any non-\/zero vector if you don\textquotesingle{}t know. If return value is 0, ioV = (0, 0, 0). If the return value is bigger than 0 but smaller than FLT\+\_\+\+MAX, ioV will be the separating axis in the direction from A to B and its length the squared distance between A and B. If the return value is FLT\+\_\+\+MAX, ioV will be the separating axis in the direction from A to B and the magnitude of the vector is meaningless. \\
\hline
{\em out\+PointA,out\+PointB} & If the return value is 0 the points are invalid. If the return value is bigger than 0 but smaller than FLT\+\_\+\+MAX these will contain the closest point on A and B. If the return value is FLT\+\_\+\+MAX the points are invalid.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The squared distance between A and B or FLT\+\_\+\+MAX when they are further away than in\+Max\+Dist\+Sq. 
\end{DoxyReturn}
\Hypertarget{classGJKClosestPoint_a73d6f276fb275026a0126ca7361fb2bf}\label{classGJKClosestPoint_a73d6f276fb275026a0126ca7361fb2bf} 
\index{GJKClosestPoint@{GJKClosestPoint}!GetClosestPointsSimplex@{GetClosestPointsSimplex}}
\index{GetClosestPointsSimplex@{GetClosestPointsSimplex}!GJKClosestPoint@{GJKClosestPoint}}
\doxysubsubsection{\texorpdfstring{GetClosestPointsSimplex()}{GetClosestPointsSimplex()}}
{\footnotesize\ttfamily void GJKClosest\+Point\+::\+Get\+Closest\+Points\+Simplex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVec3}{Vec3}} \texorpdfstring{$\ast$}{*}}]{outY,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \texorpdfstring{$\ast$}{*}}]{outP,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \texorpdfstring{$\ast$}{*}}]{outQ,  }\item[{uint \&}]{out\+Num\+Points }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the resulting simplex after the Get\+Closest\+Points algorithm finishes. If it returned a squared distance of 0, the origin will be contained in the simplex. \Hypertarget{classGJKClosestPoint_a20ab4d36efcf62ceae244ec75eb4bc23}\label{classGJKClosestPoint_a20ab4d36efcf62ceae244ec75eb4bc23} 
\index{GJKClosestPoint@{GJKClosestPoint}!Intersects@{Intersects}}
\index{Intersects@{Intersects}!GJKClosestPoint@{GJKClosestPoint}}
\doxysubsubsection{\texorpdfstring{Intersects()}{Intersects()}}
{\footnotesize\ttfamily template$<$typename A , typename B $>$ \\
bool GJKClosest\+Point\+::\+Intersects (\begin{DoxyParamCaption}\item[{const A \&}]{inA,  }\item[{const B \&}]{inB,  }\item[{float}]{in\+Tolerance,  }\item[{\mbox{\hyperlink{classVec3}{Vec3}} \&}]{ioV }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Test if inA and inB intersect


\begin{DoxyParams}{Parameters}
{\em inA} & The convex object A, must support the Get\+Support(\+Vec3) function. \\
\hline
{\em inB} & The convex object B, must support the Get\+Support(\+Vec3) function. \\
\hline
{\em in\+Tolerance} & Minimal distance between objects when the objects are considered to be colliding \\
\hline
{\em ioV} & is used as initial separating axis (provide a zero vector if you don\textquotesingle{}t know yet)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if they intersect (in which case ioV = (0, 0, 0)). False if they don\textquotesingle{}t intersect in which case ioV is a separating axis in the direction from A to B (magnitude is meaningless) 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
includes/jolt/\+Geometry/GJKClosest\+Point.\+h\end{DoxyCompactItemize}
