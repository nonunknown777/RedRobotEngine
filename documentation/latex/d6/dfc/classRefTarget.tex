\doxysection{Ref\+Target\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classRefTarget}{}\label{classRefTarget}\index{RefTarget$<$ T $>$@{RefTarget$<$ T $>$}}


{\ttfamily \#include $<$Reference.\+h$>$}



Collaboration diagram for Ref\+Target\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>}\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=241pt]{d4/d3a/classRefTarget__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classRefTarget_a4c8a23738e2e1dd6369520a30e250b17}\label{classRefTarget_a4c8a23738e2e1dd6369520a30e250b17} 
{\bfseries Ref\+Target} ()=default
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\Hypertarget{classRefTarget_a50444e3b659c6f93c64aee224a93f6ab}\label{classRefTarget_a50444e3b659c6f93c64aee224a93f6ab} 
{\bfseries Ref\+Target} (const \mbox{\hyperlink{classRefTarget}{Ref\+Target}} \&)
\item 
\Hypertarget{classRefTarget_ac3110b9f511287f881d7afaf26871e1b}\label{classRefTarget_ac3110b9f511287f881d7afaf26871e1b} 
{\bfseries \texorpdfstring{$\sim$}{\string~}\+Ref\+Target} ()
\begin{DoxyCompactList}\small\item\em assert no one is referencing us \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classRefTarget_a3befa746ea517453572f6f4f5fc3b099}{Set\+Embedded}} () const
\item 
\Hypertarget{classRefTarget_a1fc15bfe979bc43a7fa71c7c34f87ed0}\label{classRefTarget_a1fc15bfe979bc43a7fa71c7c34f87ed0} 
\mbox{\hyperlink{classRefTarget}{Ref\+Target}} \& {\bfseries operator=} (const \mbox{\hyperlink{classRefTarget}{Ref\+Target}} \&)
\begin{DoxyCompactList}\small\item\em Assignment operator. \end{DoxyCompactList}\item 
\Hypertarget{classRefTarget_acaf07366183c51cd8460c7d3dcd07c2d}\label{classRefTarget_acaf07366183c51cd8460c7d3dcd07c2d} 
uint32 {\bfseries Get\+Ref\+Count} () const
\begin{DoxyCompactList}\small\item\em Get current refcount of this object. \end{DoxyCompactList}\item 
\Hypertarget{classRefTarget_acf02c18a343bc9de9d6afb7c966f0363}\label{classRefTarget_acf02c18a343bc9de9d6afb7c966f0363} 
void {\bfseries Add\+Ref} () const
\begin{DoxyCompactList}\small\item\em Add or release a reference to this object. \end{DoxyCompactList}\item 
\Hypertarget{classRefTarget_a0451661dd5d85b01f969319e767993eb}\label{classRefTarget_a0451661dd5d85b01f969319e767993eb} 
void {\bfseries Release} () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classRefTarget_a58b5a94748691b18ecf651ce918ae743}\label{classRefTarget_a58b5a94748691b18ecf651ce918ae743} 
static int {\bfseries s\+Internal\+Get\+Ref\+Count\+Offset} ()
\begin{DoxyCompactList}\small\item\em INTERNAL HELPER FUNCTION USED BY SERIALIZATION. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classRefTarget_a12afba0bdae7706a0afd4d96ac128231}\label{classRefTarget_a12afba0bdae7706a0afd4d96ac128231} 
atomic$<$ uint32 $>$ {\bfseries m\+Ref\+Count} = 0
\begin{DoxyCompactList}\small\item\em Current reference count. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classRefTarget_ad37db773efa3c8756f6d95df3862b875}\label{classRefTarget_ad37db773efa3c8756f6d95df3862b875} 
static constexpr uint32 {\bfseries c\+Embedded} = 0x0ebedded
\begin{DoxyCompactList}\small\item\em A large value that gets added to the refcount to mark the object as embedded. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class T$>$\newline
class Ref\+Target$<$ T $>$}
Simple class to facilitate reference counting / releasing Derive your class from \doxylink{classRefTarget}{Ref\+Target} and you can reference it by using Ref$<$classname$>$ or Ref\+Const$<$classname$>$

Reference counting classes keep an integer which indicates how many references to the object are active. Reference counting objects are derived from \doxylink{classRefTarget}{Ref\+Target} and staT \& their life with a reference count of zero. They can then be assigned to equivalents of pointers (\doxylink{classRef}{Ref}) which will increase the reference count immediately. If the destructor of \doxylink{classRef}{Ref} is called or another object is assigned to the reference counting pointer it will decrease the reference count of the object again. If this reference count becomes zero, the object is destroyed.

This provides a very powerful mechanism to prevent memory leaks, but also gives some responsibility to the programmer. The most notable point is that you cannot have one object reference another and have the other reference the first one back, because this way the reference count of both objects will never become lower than 1, resulting in a memory leak. By carefully designing your classses (and particularly identifying who owns who in the class hierarchy) you can avoid these problems. 

\doxysubsection{Member Function Documentation}
\Hypertarget{classRefTarget_a3befa746ea517453572f6f4f5fc3b099}\label{classRefTarget_a3befa746ea517453572f6f4f5fc3b099} 
\index{RefTarget$<$ T $>$@{RefTarget$<$ T $>$}!SetEmbedded@{SetEmbedded}}
\index{SetEmbedded@{SetEmbedded}!RefTarget$<$ T $>$@{RefTarget$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{SetEmbedded()}{SetEmbedded()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void \mbox{\hyperlink{classRefTarget}{Ref\+Target}}$<$ T $>$\+::\+Set\+Embedded (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Mark this class as embedded, this means the type can be used in a compound or constructed on the stack. The Release function will never destruct the object, it is assumed the destructor will be called by whoever allocated the object and at that point in time it is checked that no references are left to the structure. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
includes/jolt/\+Core/Reference.\+h\end{DoxyCompactItemize}
