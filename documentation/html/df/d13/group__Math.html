<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZEngine: Additional Math Functions</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZEngine<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Additional Math Functions</div></div>
</div><!--header-->
<div class="contents">

<p>Additional functions for common mathematical operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9cf6fb58c36515834217c6b150b43772" id="r_ga9cf6fb58c36515834217c6b150b43772"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga9cf6fb58c36515834217c6b150b43772"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga9cf6fb58c36515834217c6b150b43772">playrho::Secant</a> (T target, U a1, T s1, U a2, T s2) noexcept</td></tr>
<tr class="memdesc:ga9cf6fb58c36515834217c6b150b43772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secant method.  <br /></td></tr>
<tr class="separator:ga9cf6fb58c36515834217c6b150b43772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccc71ac7ccd063fd81a31d78c3d2c90" id="r_ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga8ccc71ac7ccd063fd81a31d78c3d2c90">playrho::Bisect</a> (T a1, T a2) noexcept</td></tr>
<tr class="memdesc:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisection method.  <br /></td></tr>
<tr class="separator:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76721557b2b677d24efa2d0415954be5" id="r_ga76721557b2b677d24efa2d0415954be5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga76721557b2b677d24efa2d0415954be5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga76721557b2b677d24efa2d0415954be5">playrho::IsOdd</a> (T val) noexcept</td></tr>
<tr class="memdesc:ga76721557b2b677d24efa2d0415954be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-odd.  <br /></td></tr>
<tr class="separator:ga76721557b2b677d24efa2d0415954be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948ebcbc9ef959d24546e6c8ff848fa6" id="r_ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memTemplParams" colspan="2"><a id="ga948ebcbc9ef959d24546e6c8ff848fa6" name="ga948ebcbc9ef959d24546e6c8ff848fa6"></a>
template&lt;class TYPE &gt; </td></tr>
<tr class="memitem:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>playrho::Square</b> (TYPE t) noexcept</td></tr>
<tr class="memdesc:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares the given value. <br /></td></tr>
<tr class="separator:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d" id="r_gab870a9188fcc77c905807fa718a8268d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#gab870a9188fcc77c905807fa718a8268d">playrho::Atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:gab870a9188fcc77c905807fa718a8268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc-tangent of the given y and x values.  <br /></td></tr>
<tr class="separator:gab870a9188fcc77c905807fa718a8268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2133f1c2e5299035bb059d2d2706cd" id="r_ga8b2133f1c2e5299035bb059d2d2706cd"><td class="memTemplParams" colspan="2"><a id="ga8b2133f1c2e5299035bb059d2d2706cd" name="ga8b2133f1c2e5299035bb059d2d2706cd"></a>
template&lt;typename T , typename  = std::enable_if_t&lt;    IsIterable&lt;T&gt;::value &amp;&amp; IsAddable&lt;decltype(*begin(std::declval&lt;T&gt;()))&gt;::value&gt; </td></tr>
<tr class="memitem:ga8b2133f1c2e5299035bb059d2d2706cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>playrho::Average</b> (const T &amp;span)</td></tr>
<tr class="memdesc:ga8b2133f1c2e5299035bb059d2d2706cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of the given values. <br /></td></tr>
<tr class="separator:ga8b2133f1c2e5299035bb059d2d2706cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cbd801645e8c41a0345c4a73ef6eb1e" id="r_ga5cbd801645e8c41a0345c4a73ef6eb1e"><td class="memTemplParams" colspan="2"><a id="ga5cbd801645e8c41a0345c4a73ef6eb1e" name="ga5cbd801645e8c41a0345c4a73ef6eb1e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5cbd801645e8c41a0345c4a73ef6eb1e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="../../d6/d7a/structplayrho_1_1IsArithmetic.html">IsArithmetic</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>playrho::RoundOff</b> (T value, unsigned precision=100000)</td></tr>
<tr class="memdesc:ga5cbd801645e8c41a0345c4a73ef6eb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga5cbd801645e8c41a0345c4a73ef6eb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812ea5eaf66fb9d1bffa799886b2eee3" id="r_ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="memItemLeft" align="right" valign="top"><a id="ga812ea5eaf66fb9d1bffa799886b2eee3" name="ga812ea5eaf66fb9d1bffa799886b2eee3"></a>
<a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>playrho::RoundOff</b> (<a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> value, std::uint32_t precision=100000)</td></tr>
<tr class="memdesc:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58b963716375c0487ce3826c7d7ace7" id="r_gad58b963716375c0487ce3826c7d7ace7"><td class="memTemplParams" colspan="2"><a id="gad58b963716375c0487ce3826c7d7ace7" name="gad58b963716375c0487ce3826c7d7ace7"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gad58b963716375c0487ce3826c7d7ace7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/d76/structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>playrho::abs</b> (const <a class="el" href="../../de/d76/structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:gad58b963716375c0487ce3826c7d7ace7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value function for vectors. <br /></td></tr>
<tr class="separator:gad58b963716375c0487ce3826c7d7ace7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac862a8609b82126d0683ecb38a498087" id="r_gac862a8609b82126d0683ecb38a498087"><td class="memItemLeft" align="right" valign="top"><a id="gac862a8609b82126d0683ecb38a498087" name="gac862a8609b82126d0683ecb38a498087"></a>
<a class="el" href="../../d9/dbc/classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>playrho::abs</b> (const <a class="el" href="../../d9/dbc/classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a> &amp;v) noexcept</td></tr>
<tr class="memdesc:gac862a8609b82126d0683ecb38a498087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:gac862a8609b82126d0683ecb38a498087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1c1d9c6655688cefde069d1a5e7020" id="r_gaab1c1d9c6655688cefde069d1a5e7020"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaab1c1d9c6655688cefde069d1a5e7020"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#gaab1c1d9c6655688cefde069d1a5e7020">playrho::AlmostZero</a> (T value)</td></tr>
<tr class="memdesc:gaab1c1d9c6655688cefde069d1a5e7020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <br /></td></tr>
<tr class="separator:gaab1c1d9c6655688cefde069d1a5e7020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a916ac88804c89deb249a0e2673f00c" id="r_ga3a916ac88804c89deb249a0e2673f00c"><td class="memTemplParams" colspan="2"><a id="ga3a916ac88804c89deb249a0e2673f00c" name="ga3a916ac88804c89deb249a0e2673f00c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a916ac88804c89deb249a0e2673f00c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>playrho::AlmostEqual</b> (T x, T y, int ulp=2)</td></tr>
<tr class="memdesc:ga3a916ac88804c89deb249a0e2673f00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ga3a916ac88804c89deb249a0e2673f00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b52facf9e28f05e5e41f4e7b7ff54e" id="r_ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga25b52facf9e28f05e5e41f4e7b7ff54e">playrho::ModuloViaFmod</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::fmod</code>.  <br /></td></tr>
<tr class="separator:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200" id="r_ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">playrho::ModuloViaTrunc</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::trunc</code>.  <br /></td></tr>
<tr class="separator:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156a2abff11f978a8df25efbf0c10147" id="r_ga156a2abff11f978a8df25efbf0c10147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga156a2abff11f978a8df25efbf0c10147">playrho::GetNormalized</a> (<a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> value) noexcept</td></tr>
<tr class="memdesc:ga156a2abff11f978a8df25efbf0c10147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "normalized" value of the given angle.  <br /></td></tr>
<tr class="separator:ga156a2abff11f978a8df25efbf0c10147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56785e4c60180ef416fe29f68ccf525a" id="r_ga56785e4c60180ef416fe29f68ccf525a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga56785e4c60180ef416fe29f68ccf525a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga56785e4c60180ef416fe29f68ccf525a">playrho::GetAngle</a> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; value)</td></tr>
<tr class="memdesc:ga56785e4c60180ef416fe29f68ccf525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle.  <br /></td></tr>
<tr class="separator:ga56785e4c60180ef416fe29f68ccf525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac00e661c653f21ddbd0693bbb039ac" id="r_ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga1ac00e661c653f21ddbd0693bbb039ac">playrho::GetMagnitudeSquared</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the magnitude of the given iterable value.  <br /></td></tr>
<tr class="separator:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c114f129eeee63e60ec7d4703bbd65" id="r_ga85c114f129eeee63e60ec7d4703bbd65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65">playrho::GetMagnitude</a> (T value)</td></tr>
<tr class="memdesc:ga85c114f129eeee63e60ec7d4703bbd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the magnitude of the given value.  <br /></td></tr>
<tr class="separator:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451c8554a408d41df85a41650e0ada93" id="r_ga451c8554a408d41df85a41650e0ada93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga451c8554a408d41df85a41650e0ada93"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga451c8554a408d41df85a41650e0ada93">playrho::Dot</a> (const T1 a, const T2 b) noexcept</td></tr>
<tr class="memdesc:ga451c8554a408d41df85a41650e0ada93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product on two vectors (A and B).  <br /></td></tr>
<tr class="separator:ga451c8554a408d41df85a41650e0ada93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804d55e7545685ee9841c239bdac7c8f" id="r_ga804d55e7545685ee9841c239bdac7c8f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size&lt; T1 &gt;::value==2 &amp;&amp;std::tuple_size&lt; T2 &gt;::value==2, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga804d55e7545685ee9841c239bdac7c8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga804d55e7545685ee9841c239bdac7c8f">playrho::Cross</a> (T1 a, T2 b) noexcept</td></tr>
<tr class="memdesc:ga804d55e7545685ee9841c239bdac7c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2-element analog of the cross product of two vectors.  <br /></td></tr>
<tr class="separator:ga804d55e7545685ee9841c239bdac7c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3846333746b73978c91e250c6f239ce3" id="r_ga3846333746b73978c91e250c6f239ce3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga3846333746b73978c91e250c6f239ce3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga3846333746b73978c91e250c6f239ce3">playrho::Solve</a> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt; mat, const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; b) noexcept</td></tr>
<tr class="memdesc:ga3846333746b73978c91e250c6f239ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <br /></td></tr>
<tr class="separator:ga3846333746b73978c91e250c6f239ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cc9646bab6ce84d6b4704f8c1e0ade" id="r_ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memTemplParams" colspan="2"><a id="ga00cc9646bab6ce84d6b4704f8c1e0ade" name="ga00cc9646bab6ce84d6b4704f8c1e0ade"></a>
template&lt;class IN_TYPE &gt; </td></tr>
<tr class="memitem:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>playrho::Invert</b> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; IN_TYPE &gt; value) noexcept</td></tr>
<tr class="memdesc:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the given value. <br /></td></tr>
<tr class="separator:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4795a90a377c5335ce5b1900caf6d24" id="r_gab4795a90a377c5335ce5b1900caf6d24"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#gab4795a90a377c5335ce5b1900caf6d24">playrho::Solve33</a> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> b) noexcept</td></tr>
<tr class="memdesc:gab4795a90a377c5335ce5b1900caf6d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <br /></td></tr>
<tr class="separator:gab4795a90a377c5335ce5b1900caf6d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0606abee6bd0cc122578a2a640f044" id="r_ga0a0606abee6bd0cc122578a2a640f044"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a0606abee6bd0cc122578a2a640f044"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga0a0606abee6bd0cc122578a2a640f044">playrho::Solve22</a> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const T b) noexcept</td></tr>
<tr class="memdesc:ga0a0606abee6bd0cc122578a2a640f044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <br /></td></tr>
<tr class="separator:ga0a0606abee6bd0cc122578a2a640f044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaceaa1218e1f86e27e6678db247bc79" id="r_gaeaceaa1218e1f86e27e6678db247bc79"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#gaeaceaa1218e1f86e27e6678db247bc79">playrho::GetInverse22</a> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gaeaceaa1218e1f86e27e6678db247bc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the inverse of the given matrix as a 2-by-2.  <br /></td></tr>
<tr class="separator:gaeaceaa1218e1f86e27e6678db247bc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a513e105038f6425bfc83180a69cd3" id="r_gae7a513e105038f6425bfc83180a69cd3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#gae7a513e105038f6425bfc83180a69cd3">playrho::GetSymInverse33</a> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gae7a513e105038f6425bfc83180a69cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the symmetric inverse of this matrix as a 3-by-3.  <br /></td></tr>
<tr class="separator:gae7a513e105038f6425bfc83180a69cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa0aece94173885da01b5e3a6737af7" id="r_ga6aa0aece94173885da01b5e3a6737af7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6aa0aece94173885da01b5e3a6737af7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga6aa0aece94173885da01b5e3a6737af7">playrho::GetRevPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga6aa0aece94173885da01b5e3a6737af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector.  <br /></td></tr>
<tr class="separator:ga6aa0aece94173885da01b5e3a6737af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b57d633b625c58f9200a201e4664a7" id="r_ga87b57d633b625c58f9200a201e4664a7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga87b57d633b625c58f9200a201e4664a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga87b57d633b625c58f9200a201e4664a7">playrho::GetFwdPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga87b57d633b625c58f9200a201e4664a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector clockwise (forward-clockwise) perpendicular to the given vector.  <br /></td></tr>
<tr class="separator:ga87b57d633b625c58f9200a201e4664a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac898f9ba1986f3886cb93c0668613c41" id="r_gac898f9ba1986f3886cb93c0668613c41"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, typename T1 , std::size_t N, typename T2 &gt; </td></tr>
<tr class="memitem:gac898f9ba1986f3886cb93c0668613c41"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#gac898f9ba1986f3886cb93c0668613c41">playrho::Transform</a> (const <a class="el" href="../../de/d76/structplayrho_1_1Vector.html">Vector</a>&lt; T1, M &gt; v, const <a class="el" href="../../d1/d9d/namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T2, M, N &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gac898f9ba1986f3886cb93c0668613c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an M-element vector by an M-by-N matrix.  <br /></td></tr>
<tr class="separator:gac898f9ba1986f3886cb93c0668613c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a7716aaab729705e73d4d533e81672" id="r_ga52a7716aaab729705e73d4d533e81672"><td class="memItemLeft" align="right" valign="top"><a id="ga52a7716aaab729705e73d4d533e81672" name="ga52a7716aaab729705e73d4d533e81672"></a>
constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>playrho::Transform</b> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> v, const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga52a7716aaab729705e73d4d533e81672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by a matrix. <br /></td></tr>
<tr class="separator:ga52a7716aaab729705e73d4d533e81672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819a9ef6f9c3d492b5177ca25077618e" id="r_ga819a9ef6f9c3d492b5177ca25077618e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga819a9ef6f9c3d492b5177ca25077618e">playrho::InverseTransform</a> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> v, const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="separator:ga819a9ef6f9c3d492b5177ca25077618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471bae6413067374ab8d8262533e402" id="r_gab471bae6413067374ab8d8262533e402"><td class="memItemLeft" align="right" valign="top"><a id="gab471bae6413067374ab8d8262533e402" name="gab471bae6413067374ab8d8262533e402"></a>
constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><b>playrho::MulT</b> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gab471bae6413067374ab8d8262533e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A^T * B. <br /></td></tr>
<tr class="separator:gab471bae6413067374ab8d8262533e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fee43efb2fa412b816e9e0a7df87f8" id="r_ga94fee43efb2fa412b816e9e0a7df87f8"><td class="memItemLeft" align="right" valign="top"><a id="ga94fee43efb2fa412b816e9e0a7df87f8" name="ga94fee43efb2fa412b816e9e0a7df87f8"></a>
<a class="el" href="../../d1/d9d/namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><b>playrho::abs</b> (const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A)</td></tr>
<tr class="memdesc:ga94fee43efb2fa412b816e9e0a7df87f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:ga94fee43efb2fa412b816e9e0a7df87f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e157fe9f9288debcd4be111a2485991" id="r_ga2e157fe9f9288debcd4be111a2485991"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2e157fe9f9288debcd4be111a2485991"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga2e157fe9f9288debcd4be111a2485991">playrho::NextPowerOfTwo</a> (T x)</td></tr>
<tr class="memdesc:ga2e157fe9f9288debcd4be111a2485991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next largest power of 2.  <br /></td></tr>
<tr class="separator:ga2e157fe9f9288debcd4be111a2485991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d2525a406c1f83c0574e46a2cee32" id="r_ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memItemLeft" align="right" valign="top"><a id="ga0c7d2525a406c1f83c0574e46a2cee32" name="ga0c7d2525a406c1f83c0574e46a2cee32"></a>
<a class="el" href="../../d1/d9d/namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>playrho::Normalize</b> (<a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;vector)</td></tr>
<tr class="memdesc:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given vector into a unit vector and returns its original length. <br /></td></tr>
<tr class="separator:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae769785f0540a4b8960b282f6b105c14" id="r_gae769785f0540a4b8960b282f6b105c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#gae769785f0540a4b8960b282f6b105c14">playrho::ComputeCentroid</a> (const <a class="el" href="../../db/d56/classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:gae769785f0540a4b8960b282f6b105c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a counter-clockwise array of 3 or more vertices.  <br /></td></tr>
<tr class="separator:gae769785f0540a4b8960b282f6b105c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3970833d43e94acccda025c9f6959594" id="r_ga3970833d43e94acccda025c9f6959594"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3970833d43e94acccda025c9f6959594"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga3970833d43e94acccda025c9f6959594">playrho::GetModuloNext</a> (T value, T count) noexcept -&gt; T</td></tr>
<tr class="memdesc:ga3970833d43e94acccda025c9f6959594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo next value.  <br /></td></tr>
<tr class="separator:ga3970833d43e94acccda025c9f6959594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff989523e82e44e08f8cdee3451674a" id="r_ga1ff989523e82e44e08f8cdee3451674a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1ff989523e82e44e08f8cdee3451674a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga1ff989523e82e44e08f8cdee3451674a">playrho::GetModuloPrev</a> (T value, T count) noexcept -&gt; T</td></tr>
<tr class="memdesc:ga1ff989523e82e44e08f8cdee3451674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo previous value.  <br /></td></tr>
<tr class="separator:ga1ff989523e82e44e08f8cdee3451674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c036532db1260373b97c1d85360894c" id="r_ga8c036532db1260373b97c1d85360894c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga8c036532db1260373b97c1d85360894c">playrho::GetDelta</a> (<a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="memdesc:ga8c036532db1260373b97c1d85360894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shortest angular distance to go from angle 1 to angle 2.  <br /></td></tr>
<tr class="separator:ga8c036532db1260373b97c1d85360894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07dcf271b85b501cd2d7188902066e55" id="r_ga07dcf271b85b501cd2d7188902066e55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga07dcf271b85b501cd2d7188902066e55">playrho::GetRevRotationalAngle</a> (<a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="separator:ga07dcf271b85b501cd2d7188902066e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8e8abc999b0c63cf1921b0edcf0b36" id="r_ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memItemLeft" align="right" valign="top"><a id="ga3b8e8abc999b0c63cf1921b0edcf0b36" name="ga3b8e8abc999b0c63cf1921b0edcf0b36"></a>
std::vector&lt; <a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>playrho::GetCircleVertices</b> (<a class="el" href="../../dc/dca/group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius, unsigned slices, <a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> start=0_deg, <a class="el" href="../../d1/d9d/namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> turns=<a class="el" href="../../d1/d9d/namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{1})</td></tr>
<tr class="memdesc:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertices for a circle described by the given parameters. <br /></td></tr>
<tr class="separator:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb57dabfe8d3db9e509a6b493173358" id="r_ga0eb57dabfe8d3db9e509a6b493173358"><td class="memItemLeft" align="right" valign="top"><a id="ga0eb57dabfe8d3db9e509a6b493173358" name="ga0eb57dabfe8d3db9e509a6b493173358"></a>
<a class="el" href="../../dd/d88/group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt; <a class="el" href="../../dc/dca/group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>playrho::GetAreaOfCircle</b> (<a class="el" href="../../dc/dca/group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius)</td></tr>
<tr class="memdesc:ga0eb57dabfe8d3db9e509a6b493173358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a circle. <br /></td></tr>
<tr class="separator:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118f8284073d2638e48ef8f13177e1d9" id="r_ga118f8284073d2638e48ef8f13177e1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d88/group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt; <a class="el" href="../../dc/dca/group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga118f8284073d2638e48ef8f13177e1d9">playrho::GetAreaOfPolygon</a> (<a class="el" href="../../db/d56/classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga118f8284073d2638e48ef8f13177e1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a polygon.  <br /></td></tr>
<tr class="separator:ga118f8284073d2638e48ef8f13177e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760adfdd1cb30bdae8cd37c1ae5da485" id="r_ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#ga9ded7e1044d55beb1ca2957d671ece44">SecondMomentOfArea</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">playrho::GetPolarMoment</a> (<a class="el" href="../../db/d56/classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the polar moment of the area enclosed by the given vertices.  <br /></td></tr>
<tr class="separator:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901850dd04519b8e6d642ab96a10d9ea" id="r_ga901850dd04519b8e6d642ab96a10d9ea"><td class="memTemplParams" colspan="2"><a id="ga901850dd04519b8e6d642ab96a10d9ea" name="ga901850dd04519b8e6d642ab96a10d9ea"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga901850dd04519b8e6d642ab96a10d9ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d6/da1/classVector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="../../d6/da1/classVector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga901850dd04519b8e6d642ab96a10d9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value function for vectors. <br /></td></tr>
<tr class="separator:ga901850dd04519b8e6d642ab96a10d9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Additional functions for common mathematical operations. </p>
<p>These are non-member non-friend functions for mathematical operations especially those with mixed input and output types. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaab1c1d9c6655688cefde069d1a5e7020" name="gaab1c1d9c6655688cefde069d1a5e7020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab1c1d9c6655688cefde069d1a5e7020">&#9670;&#160;</a></span>AlmostZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt; playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether a given value is almost zero. </p>
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab870a9188fcc77c905807fa718a8268d" name="gab870a9188fcc77c905807fa718a8268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab870a9188fcc77c905807fa718a8268d">&#9670;&#160;</a></span>Atan2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::Atan2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arc-tangent of the given y and x values. </p>
<dl class="section return"><dt>Returns</dt><dd>Normalized angle - an angle between -Pi and Pi inclusively. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/numeric/math/atan2">https://en.cppreference.com/w/cpp/numeric/math/atan2</a> </dd></dl>

</div>
</div>
<a id="ga8ccc71ac7ccd063fd81a31d78c3d2c90" name="ga8ccc71ac7ccd063fd81a31d78c3d2c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ccc71ac7ccd063fd81a31d78c3d2c90">&#9670;&#160;</a></span>Bisect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::Bisect </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bisection method. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Bisection_method">https://en.wikipedia.org/wiki/Bisection_method</a> </dd></dl>

</div>
</div>
<a id="gae769785f0540a4b8960b282f6b105c14" name="gae769785f0540a4b8960b282f6b105c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae769785f0540a4b8960b282f6b105c14">&#9670;&#160;</a></span>ComputeCentroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> playrho::ComputeCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d56/classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the centroid of a counter-clockwise array of 3 or more vertices. </p>
<dl class="section note"><dt>Note</dt><dd>Behavior is undefined if there are less than 3 vertices or the vertices don't go counter-clockwise. </dd></dl>

</div>
</div>
<a id="ga804d55e7545685ee9841c239bdac7c8f" name="ga804d55e7545685ee9841c239bdac7c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804d55e7545685ee9841c239bdac7c8f">&#9670;&#160;</a></span>Cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size&lt; T1 &gt;::value==2 &amp;&amp;std::tuple_size&lt; T2 &gt;::value==2, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Cross </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the 2-element analog of the cross product of two vectors. </p>
<p>Cross-products the given two values.</p>
<p>Defined as the result of: <code>(a.x * b.y) - (a.y * b.x)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is dimension squashing. I.e. A cross of a 2-D length by a 2-D unit vector results in a 1-D length value. </dd>
<dd>
The unit of the result is the 1-D product of the inputs. </dd>
<dd>
This operation is anti-commutative. I.e. Cross(a, b) == -Cross(b, a). </dd>
<dd>
The result will be 0 if any of the following are true: vector A or vector B has a length of zero; vectors A and B point in the same direction; or vectors A and B point in exactly opposite direction of each other. </dd>
<dd>
The result will be positive if: neither vector A nor B has a length of zero; and vector B is at an angle from vector A of greater than 0 and less than 180 degrees (counter-clockwise from A being a positive angle). </dd>
<dd>
<a class="el" href="../../d8/dce/classResult.html" title="Helper class that either contains a valid result or an error.">Result</a> will be negative if: neither vector A nor B has a length of zero; and vector B is at an angle from vector A of less than 0 and greater than -180 degrees (clockwise from A being a negative angle). </dd>
<dd>
The absolute value of the result is the area of the parallelogram formed by the vectors A and B.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Cross product of the two values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation is anti-commutative. I.e. Cross(a, b) == -Cross(b, a). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value A of a 3-element type. </td></tr>
    <tr><td class="paramname">b</td><td>Value B of a 3-element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross product of the two values. </dd></dl>

</div>
</div>
<a id="ga451c8554a408d41df85a41650e0ada93" name="ga451c8554a408d41df85a41650e0ada93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451c8554a408d41df85a41650e0ada93">&#9670;&#160;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Dot </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the dot product on two vectors (A and B). </p>
<p>The dot product of two vectors is defined as: the magnitude of vector A, multiplied by, the magnitude of vector B, multiplied by, the cosine of the angle between the two vectors (A and B). Thus the dot product of two vectors is a value ranging between plus and minus the magnitudes of each vector times each other. The middle value of 0 indicates that two vectors are perpendicular to each other (at an angle of +/- 90 degrees from each other).</p>
<dl class="section note"><dt>Note</dt><dd>This operation is commutative. I.e. Dot(a, b) == Dot(b, a). </dd>
<dd>
If A and B are the same vectors, <code>GetMagnitudeSquared(Vec2)</code> returns the same value using effectively one less input parameter. </dd>
<dd>
This is similar to the <code>std::inner_product</code> standard library algorithm except benchmark tests suggest this implementation is faster at least for <code>Vec2</code> like instances.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Dot_product">https://en.wikipedia.org/wiki/Dot_product</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="../../de/d76/structplayrho_1_1Vector.html" title="Vector.">Vector</a> A. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="../../de/d76/structplayrho_1_1Vector.html" title="Vector.">Vector</a> B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors (0 means the two vectors are perpendicular). </dd></dl>

</div>
</div>
<a id="ga56785e4c60180ef416fe29f68ccf525a" name="ga56785e4c60180ef416fe29f68ccf525a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56785e4c60180ef416fe29f68ccf525a">&#9670;&#160;</a></span>GetAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the angle. </p>
<dl class="section return"><dt>Returns</dt><dd>Angular value in the range of -Pi to +Pi radians. </dd></dl>

</div>
</div>
<a id="ga118f8284073d2638e48ef8f13177e1d9" name="ga118f8284073d2638e48ef8f13177e1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118f8284073d2638e48ef8f13177e1d9">&#9670;&#160;</a></span>GetAreaOfPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d88/group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt; <a class="el" href="../../dc/dca/group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt; playrho::GetAreaOfPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d56/classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the area of a polygon. </p>
<dl class="section note"><dt>Note</dt><dd>This function is valid for any non-self-intersecting (simple) polygon, which can be convex or concave. </dd>
<dd>
Winding order doesn't matter. </dd></dl>

</div>
</div>
<a id="ga8c036532db1260373b97c1d85360894c" name="ga8c036532db1260373b97c1d85360894c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c036532db1260373b97c1d85360894c">&#9670;&#160;</a></span>GetDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetDelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the shortest angular distance to go from angle 1 to angle 2. </p>
<p>This gets the angle to rotate angle 1 by in order to get to angle 2 with the least amount of rotation. </p><dl class="section return"><dt>Returns</dt><dd>Angle between -Pi and Pi radians inclusively. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d13/group__Math.html#ga156a2abff11f978a8df25efbf0c10147" title="Gets the &quot;normalized&quot; value of the given angle.">GetNormalized</a> </dd></dl>

</div>
</div>
<a id="ga87b57d633b625c58f9200a201e4664a7" name="ga87b57d633b625c58f9200a201e4664a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b57d633b625c58f9200a201e4664a7">&#9670;&#160;</a></span>GetFwdPerpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetFwdPerpendicular </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a vector clockwise (forward-clockwise) perpendicular to the given vector. </p>
<p>This takes a vector of form (x, y) and returns the vector (y, -x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="../../de/d76/structplayrho_1_1Vector.html" title="Vector.">Vector</a> to return a clockwise perpendicular equivalent for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A clockwise 90-degree rotation of the given vector. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d13/group__Math.html#ga6aa0aece94173885da01b5e3a6737af7" title="Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector.">GetRevPerpendicular</a>. </dd></dl>

</div>
</div>
<a id="gaeaceaa1218e1f86e27e6678db247bc79" name="gaeaceaa1218e1f86e27e6678db247bc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaceaa1218e1f86e27e6678db247bc79">&#9670;&#160;</a></span>GetInverse22()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> playrho::GetInverse22 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the inverse of the given matrix as a 2-by-2. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero matrix if singular. </dd></dl>

</div>
</div>
<a id="ga85c114f129eeee63e60ec7d4703bbd65" name="ga85c114f129eeee63e60ec7d4703bbd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c114f129eeee63e60ec7d4703bbd65">&#9670;&#160;</a></span>GetMagnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::GetMagnitude </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the magnitude of the given value. </p>
<dl class="section note"><dt>Note</dt><dd>Works for any type for which <code>GetMagnitudeSquared</code> also works. </dd></dl>

</div>
</div>
<a id="ga1ac00e661c653f21ddbd0693bbb039ac" name="ga1ac00e661c653f21ddbd0693bbb039ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ac00e661c653f21ddbd0693bbb039ac">&#9670;&#160;</a></span>GetMagnitudeSquared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetMagnitudeSquared </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the square of the magnitude of the given iterable value. </p>
<dl class="section note"><dt>Note</dt><dd>For performance, use this instead of <code><a class="el" href="../../df/d13/group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65" title="Gets the magnitude of the given value.">GetMagnitude(T value)</a></code> (if possible). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative value from 0 to infinity, or NaN. </dd></dl>

</div>
</div>
<a id="ga3970833d43e94acccda025c9f6959594" name="ga3970833d43e94acccda025c9f6959594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3970833d43e94acccda025c9f6959594">&#9670;&#160;</a></span>GetModuloNext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetModuloNext </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the modulo next value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given value is less than the given count. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if the given value is not less than the given count. </dd></dl>

</div>
</div>
<a id="ga1ff989523e82e44e08f8cdee3451674a" name="ga1ff989523e82e44e08f8cdee3451674a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ff989523e82e44e08f8cdee3451674a">&#9670;&#160;</a></span>GetModuloPrev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetModuloPrev </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the modulo previous value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given value is less than the given count. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if the given value is not less than the given count. </dd></dl>

</div>
</div>
<a id="ga156a2abff11f978a8df25efbf0c10147" name="ga156a2abff11f978a8df25efbf0c10147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156a2abff11f978a8df25efbf0c10147">&#9670;&#160;</a></span>GetNormalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetNormalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the "normalized" value of the given angle. </p>
<dl class="section return"><dt>Returns</dt><dd>Angle between -Pi and Pi radians inclusively where 0 represents the positive X-axis. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d13/group__Math.html#gab870a9188fcc77c905807fa718a8268d" title="Computes the arc-tangent of the given y and x values.">Atan2</a> </dd></dl>

</div>
</div>
<a id="ga760adfdd1cb30bdae8cd37c1ae5da485" name="ga760adfdd1cb30bdae8cd37c1ae5da485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760adfdd1cb30bdae8cd37c1ae5da485">&#9670;&#160;</a></span>GetPolarMoment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#ga9ded7e1044d55beb1ca2957d671ece44">SecondMomentOfArea</a> playrho::GetPolarMoment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d56/classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the polar moment of the area enclosed by the given vertices. </p>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if given collection has less than 3 vertices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Collection of three or more vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6aa0aece94173885da01b5e3a6737af7" name="ga6aa0aece94173885da01b5e3a6737af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa0aece94173885da01b5e3a6737af7">&#9670;&#160;</a></span>GetRevPerpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetRevPerpendicular </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector. </p>
<p>This takes a vector of form (x, y) and returns the vector (-y, x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="../../de/d76/structplayrho_1_1Vector.html" title="Vector.">Vector</a> to return a counter-clockwise perpendicular equivalent for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A counter-clockwise 90-degree rotation of the given vector. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d13/group__Math.html#ga87b57d633b625c58f9200a201e4664a7" title="Gets a vector clockwise (forward-clockwise) perpendicular to the given vector.">GetFwdPerpendicular</a>. </dd></dl>

</div>
</div>
<a id="ga07dcf271b85b501cd2d7188902066e55" name="ga07dcf271b85b501cd2d7188902066e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07dcf271b85b501cd2d7188902066e55">&#9670;&#160;</a></span>GetRevRotationalAngle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> playrho::GetRevRotationalAngle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dca/group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2. </p><dl class="section return"><dt>Returns</dt><dd>Angular rotation in the counter clockwise direction to go from angle 1 to angle 2. </dd></dl>

</div>
</div>
<a id="gae7a513e105038f6425bfc83180a69cd3" name="gae7a513e105038f6425bfc83180a69cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a513e105038f6425bfc83180a69cd3">&#9670;&#160;</a></span>GetSymInverse33()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> playrho::GetSymInverse33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the symmetric inverse of this matrix as a 3-by-3. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero matrix if singular. </dd></dl>

</div>
</div>
<a id="ga819a9ef6f9c3d492b5177ca25077618e" name="ga819a9ef6f9c3d492b5177ca25077618e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga819a9ef6f9c3d492b5177ca25077618e">&#9670;&#160;</a></span>InverseTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> playrho::InverseTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another (inverse transform). </p>

</div>
</div>
<a id="ga76721557b2b677d24efa2d0415954be5" name="ga76721557b2b677d24efa2d0415954be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76721557b2b677d24efa2d0415954be5">&#9670;&#160;</a></span>IsOdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::IsOdd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is-odd. </p>
<p>Determines whether the given integral value is odd (as opposed to being even). </p>

</div>
</div>
<a id="ga25b52facf9e28f05e5e41f4e7b7ff54e" name="ga25b52facf9e28f05e5e41f4e7b7ff54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b52facf9e28f05e5e41f4e7b7ff54e">&#9670;&#160;</a></span>ModuloViaFmod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::ModuloViaFmod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo operation using <code>std::fmod</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Modulo via <code>std::fmod</code> appears slower than via <code>std::trunc</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d13/group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200" title="Modulo operation using std::trunc.">ModuloViaTrunc</a> </dd></dl>

</div>
</div>
<a id="ga84e7cb2a415fcb956202c8d7e1b1d200" name="ga84e7cb2a415fcb956202c8d7e1b1d200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e7cb2a415fcb956202c8d7e1b1d200">&#9670;&#160;</a></span>ModuloViaTrunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::ModuloViaTrunc </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo operation using <code>std::trunc</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Modulo via <code>std::fmod</code> appears slower than via <code>std::trunc</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d13/group__Math.html#ga25b52facf9e28f05e5e41f4e7b7ff54e" title="Modulo operation using std::fmod.">ModuloViaFmod</a> </dd></dl>

</div>
</div>
<a id="ga2e157fe9f9288debcd4be111a2485991" name="ga2e157fe9f9288debcd4be111a2485991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e157fe9f9288debcd4be111a2485991">&#9670;&#160;</a></span>NextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::NextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next largest power of 2. </p>
<p>Given a binary integer value x, the next largest power of 2 can be computed by a S.W.A.R. algorithm that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with the same most significant 1 as x, but all one's below it. Adding 1 to that value yields the next largest power of 2. </p>

</div>
</div>
<a id="ga9cf6fb58c36515834217c6b150b43772" name="ga9cf6fb58c36515834217c6b150b43772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cf6fb58c36515834217c6b150b43772">&#9670;&#160;</a></span>Secant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U playrho::Secant </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Secant method. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Secant_method">https://en.wikipedia.org/wiki/Secant_method</a> </dd></dl>

</div>
</div>
<a id="ga3846333746b73978c91e250c6f239ce3" name="ga3846333746b73978c91e250c6f239ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3846333746b73978c91e250c6f239ce3">&#9670;&#160;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd></dl>

</div>
</div>
<a id="ga0a0606abee6bd0cc122578a2a640f044" name="ga0a0606abee6bd0cc122578a2a640f044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a0606abee6bd0cc122578a2a640f044">&#9670;&#160;</a></span>Solve22()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::Solve22 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd>
<dd>
Solves only the upper 2-by-2 matrix equation. </dd></dl>

</div>
</div>
<a id="gab4795a90a377c5335ce5b1900caf6d24" name="gab4795a90a377c5335ce5b1900caf6d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4795a90a377c5335ce5b1900caf6d24">&#9670;&#160;</a></span>Solve33()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/d9d/namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> playrho::Solve33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd></dl>

</div>
</div>
<a id="gac898f9ba1986f3886cb93c0668613c41" name="gac898f9ba1986f3886cb93c0668613c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac898f9ba1986f3886cb93c0668613c41">&#9670;&#160;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M, typename T1 , std::size_t N, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d76/structplayrho_1_1Vector.html">Vector</a>&lt; T1, M &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d9d/namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T2, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies an M-element vector by an M-by-N matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../de/d76/structplayrho_1_1Vector.html" title="Vector.">Vector</a> that's interpreted as a matrix with 1 row and M-columns. </td></tr>
    <tr><td class="paramname">m</td><td>An M-row by N-column <em>transformation matrix</em> to multiply the vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Transformation_matrix">https://en.wikipedia.org/wiki/Transformation_matrix</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
